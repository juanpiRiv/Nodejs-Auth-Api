# Proyecto E-commerce API

API backend robusta y profesional para una plataforma de e-commerce, desarrollada con Node.js, Express y MongoDB. Incluye autenticaci√≥n, autorizaci√≥n por roles, gesti√≥n de carrito de compras, sistema de tickets y m√°s.

## üì¶ Instalaci√≥n

Sigue estos pasos para levantar el proyecto en tu entorno local:

1.  **Clonar el repositorio:**
    ```bash
    git clone https://github.com/juanpiRiv/Nodejs-Auth-Api
    cd Api+Auth
    ```


2.  **Instalar dependencias:**
    Aseg√∫rate de tener Node.js y npm instalados. Luego, ejecuta:
    ```bash
    npm install
    ```

3.  **Configurar variables de entorno:**
    Crea un archivo `.env` en la ra√≠z del directorio `ecommerce-api` (o donde se encuentre tu `package.json`). Puedes copiar el siguiente ejemplo y modificar los valores seg√∫n tu configuraci√≥n:

    ```env
    # .env.example
    PORT=8080
    MONGO_URI=mongodb+srv://tu_usuario:tu_password@tu_cluster.mongodb.net/tu_base_de_datos?retryWrites=true&w=majority
    JWT_SECRET=tu_secreto_jwt_aqui
    JWT_COOKIE_NAME=authToken
    TWILIO_ACCOUNT_SID=tu_twilio_account_sid
    TWILIO_AUTH_TOKEN=tu_twilio_auth_token
    TWILIO_PHONE=tu_numero_twilio
    ADMIN_PHONE=tu_numero_admin_para_tests
    MAIL_USER=tu_email_gmail
    MAIL_PASS=tu_password_de_aplicacion_gmail
    ```
    **Importante:** Reemplaza los valores de ejemplo con tus propias credenciales y configuraciones. Para `MAIL_PASS`, si usas Gmail, necesitar√°s generar una "Contrase√±a de aplicaci√≥n".

4.  **Iniciar el servidor:**
    Una vez configurado el `.env`, puedes iniciar el servidor en modo desarrollo con:
    ```bash
    npm run dev
    ```
    El servidor deber√≠a estar corriendo en `http://localhost:PORT` (el puerto especificado en tu `.env`).

## ‚öô Variables de Entorno Necesarias (`.env`)

A continuaci√≥n se detallan las variables de entorno que el proyecto utiliza:

*   `PORT`: Puerto en el que correr√° el servidor (ej. `8080`).
*   `MONGO_URI`: URI de conexi√≥n a tu base de datos MongoDB.
*   `JWT_SECRET`: Clave secreta para la firma de JSON Web Tokens (JWT).
*   `JWT_COOKIE_NAME`: Nombre de la cookie donde se almacenar√° el token JWT.
*   `TWILIO_ACCOUNT_SID`: Account SID de tu cuenta de Twilio (para env√≠o de SMS, si aplica).
*   `TWILIO_AUTH_TOKEN`: Auth Token de tu cuenta de Twilio.
*   `TWILIO_PHONE`: N√∫mero de tel√©fono de Twilio desde el cual se enviar√°n mensajes.
*   `ADMIN_PHONE`: N√∫mero de tel√©fono del administrador para pruebas o notificaciones.
*   `MAIL_USER`: Direcci√≥n de correo electr√≥nico (Gmail) para el env√≠o de emails (ej. confirmaci√≥n de compra).
*   `MAIL_PASS`: Contrase√±a de aplicaci√≥n de Gmail para `MAIL_USER`.

## üîê Roles Disponibles

El sistema maneja dos roles principales para los usuarios:

*   **`user`**: Rol por defecto para los clientes que se registran. Pueden navegar por los productos, agregarlos al carrito, realizar compras y ver sus tickets.
*   **`admin`**: Rol con permisos elevados. Adem√°s de las acciones de un usuario normal, los administradores pueden gestionar productos (crear, editar, eliminar), ver todos los usuarios, y potencialmente acceder a otras funcionalidades de gesti√≥n del sistema.

La autorizaci√≥n se maneja mediante middlewares que verifican el rol del usuario autenticado antes de permitir el acceso a ciertas rutas o la ejecuci√≥n de acciones espec√≠ficas.

## üìÇ Estructura de Carpetas

El proyecto sigue una estructura modular para facilitar la organizaci√≥n y el mantenimiento del c√≥digo:

```
ecommerce-api/
‚îú‚îÄ‚îÄ logs/               # Archivos de logs generados por Winston
‚îú‚îÄ‚îÄ public/             # Archivos p√∫blicos (si aplica, ej. para vistas o assets est√°ticos)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/         # Configuraciones (Passport, logger, variables de entorno, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ controllers/    # L√≥gica de negocio y manejo de solicitudes/respuestas HTTP
‚îÇ   ‚îú‚îÄ‚îÄ dao/            # Data Access Objects (interacci√≥n directa con la base de datos)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ managers/   # Clases Manager que utilizan los modelos Mongoose
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models/     # Modelos de Mongoose para las colecciones de MongoDB
‚îÇ   ‚îú‚îÄ‚îÄ dtos/           # Data Transfer Objects (para estructurar datos entre capas)
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/    # Middlewares de Express (autenticaci√≥n, autorizaci√≥n, errores, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ repositories/   # Patr√≥n Repository (abstracci√≥n sobre los DAOs)
‚îÇ   ‚îú‚îÄ‚îÄ routes/         # Definici√≥n de las rutas de la API
‚îÇ   ‚îú‚îÄ‚îÄ services/       # L√≥gica de servicios (puede incluir interacci√≥n con APIs externas, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ utils/          # Funciones de utilidad (manejo de JWT, encriptaci√≥n, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ validations/    # Esquemas de validaci√≥n (Joi) para los datos de entrada
‚îÇ   ‚îî‚îÄ‚îÄ server.js       # Archivo principal de inicio del servidor Express
‚îú‚îÄ‚îÄ .env                # Archivo de variables de entorno (NO subir a Git)
‚îú‚îÄ‚îÄ .gitignore          # Archivos y carpetas ignorados por Git
‚îú‚îÄ‚îÄ package-lock.json   # Dependencias bloqueadas
‚îú‚îÄ‚îÄ package.json        # Metadatos del proyecto y dependencias
‚îî‚îÄ‚îÄ README.md           # Este archivo
```

## üß™ Uso de la Colecci√≥n Postman

Se proporciona una colecci√≥n de Postman (`Auth+Api.postman_collection.json`) con todos los endpoints listos para ser probados.

**C√≥mo importar y usar:**

1.  Abre Postman.
2.  Haz clic en `Import` (generalmente en la esquina superior izquierda).
3.  Selecciona la pesta√±a `File` y luego `Upload Files`.
4.  Navega hasta el archivo `Auth+Api.postman_collection.json` en la ra√≠z del proyecto y selecci√≥nalo.
5.  Una vez importada, encontrar√°s la colecci√≥n en el panel lateral de Postman.
6.  **Importante:** Algunos endpoints requieren autenticaci√≥n (JWT). Generalmente, despu√©s de hacer login (`POST /api/sessions/login`), el token JWT se guarda autom√°ticamente en una cookie (`authToken`) que Postman deber√≠a enviar en las solicitudes subsiguientes. Si no, aseg√∫rate de configurar Postman para que env√≠e cookies o incluye el token manualmente en el header `Authorization` como `Bearer TU_TOKEN_AQUI` si la API est√° configurada para aceptarlo as√≠ tambi√©n. Revisa la configuraci√≥n de autenticaci√≥n de cada request en Postman.

##  Principales Endpoints (Ejemplos)

Aqu√≠ algunos de los endpoints clave para interactuar con la API. Aseg√∫rate de que el servidor est√© corriendo. Por defecto, las rutas est√°n prefijadas con `/api`.

*   **Crear un nuevo producto (Admin):**
    `POST /api/products`
    Body (JSON):
    ```json
    {
      "title": "Nuevo Producto de Prueba",
      "description": "Descripci√≥n detallada del producto.",
      "price": 199.99,
      "code": "NP001",
      "stock": 50,
      "category": "Electr√≥nicos",
      "thumbnails": ["url_imagen1.jpg", "url_imagen2.jpg"]
    }
    ```

*   **Realizar una compra (Finalizar carrito):**
    `POST /api/carts/:cid/purchase`
    (Reemplaza `:cid` con el ID del carrito correspondiente. Requiere autenticaci√≥n de usuario.)

*   **Obtener tickets de compra (Usuario autenticado):**
    `GET /api/tickets`
    (Devuelve los tickets asociados al usuario logueado.)

Consulta la colecci√≥n de Postman para ver todos los endpoints disponibles, sus par√°metros, cuerpos de solicitud esperados y ejemplos de respuesta.

## üìÑ Documentaci√≥n de la API con Swagger

La API cuenta con documentaci√≥n interactiva generada con Swagger (OpenAPI). Esto permite explorar los endpoints disponibles, sus par√°metros, modelos de datos y probar las solicitudes directamente desde el navegador.

Para acceder a la documentaci√≥n de Swagger, una vez que el servidor est√© corriendo (ya sea localmente o en Docker), navega a la siguiente URL:

`http://localhost:PORT/api-docs`

(Reemplaza `PORT` con el puerto en el que est√© corriendo la aplicaci√≥n, por defecto 8080).

##  Documentaci√≥n de la API con Swagger

La API cuenta con documentaci√≥n interactiva generada con Swagger (OpenAPI). Esto permite explorar los endpoints disponibles, sus par√°metros, modelos de datos y probar las solicitudes directamente desde el navegador.

Para acceder a la documentaci√≥n de Swagger, una vez que el servidor est√© corriendo (ya sea localmente o en Docker), navega a la siguiente URL:

`http://localhost:PORT/api-docs`

(Reemplaza `PORT` con el puerto en el que est√© corriendo la aplicaci√≥n, por defecto 8080).

## üê≥ Docker

Este proyecto est√° disponible como una imagen Docker en Docker Hub. Puedes descargarla y ejecutarla f√°cilmente.

1.  **Descargar la imagen Docker:**
    ```bash
    docker pull juanpirriv/nodejs-auth-api
    ```

2.  **Ejecutar el contenedor:**
    Aseg√∫rate de tener un archivo `.env` configurado localmente con las variables de entorno necesarias (especialmente `MONGO_URI`). Luego, puedes ejecutar el contenedor mapeando el puerto y montando el archivo `.env`:
    ```bash
    docker run -d -p 8080:8080 --env-file .env juanpirriv/nodejs-auth-api
    ```
    Reemplaza `8080:8080` si necesitas mapear a un puerto diferente en tu m√°quina local. El contenedor leer√° las variables de entorno desde el archivo `.env` que le montes.

Puedes encontrar la imagen en Docker Hub aqu√≠: [https://hub.docker.com/repository/docker/juanpirriv/nodejs-auth-api](https://hub.docker.com/repository/docker/juanpirriv/nodejs-auth-api)

## ‚úÖ Tecnolog√≠as Usadas

*   **Node.js**: Entorno de ejecuci√≥n para JavaScript del lado del servidor.
*   **Docker**: Plataforma para desarrollar, enviar y ejecutar aplicaciones en contenedores.
*   **Swagger (OpenAPI)**: Para generar documentaci√≥n interactiva de la API.
*   **Express.js**: Framework web para Node.js, utilizado para construir la API.
*   **MongoDB**: Base de datos NoSQL orientada a documentos.
*   **Mongoose**: ODM (Object Data Modeling) para MongoDB y Node.js.
*   **JWT (JSON Web Tokens)**: Para la autenticaci√≥n stateless.
*   **Passport.js**: Middleware de autenticaci√≥n para Node.js (con estrategias `passport-jwt` y `passport-local`).
*   **Joi**: Para la validaci√≥n de datos de entrada.
*   **Winston**: Logger vers√°til para Node.js.
*   **Dotenv**: Para cargar variables de entorno desde un archivo `.env`.
*   **Bcrypt**: Para el hashing de contrase√±as.
*   **Nodemailer**: Para el env√≠o de correos electr√≥nicos.
*   **Twilio SDK**: Para la integraci√≥n con servicios de Twilio (SMS).
*   Y otras dependencias listadas en `package.json`.

## üìé Licencia

Este proyecto est√° bajo la Licencia MIT. Consulta el archivo `LICENSE` para m√°s detalles (si no existe, puedes crear uno con el texto est√°ndar de la licencia MIT).

```text
MIT License

Copyright (c) [2025] [JuanpiRiv]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```
 `[2025]` y `[Juan Pablo Rivero Albornoz]` .

##  Contacto / Autor

Desarrollado por **[JuanpiRiv]**

*   GitHub: `[https://github.com/juanpiRiv]`
*   Email: `[juanpirivero015@gmail.com]`
*   LinkedIn: `[https://www.linkedin.com/in/juanriveroalbornoz/]`

---

¬°Gracias por usar este proyecto!

## üß™ Testing

This project uses Mocha, Chai, and Supertest for testing the API.

### Mocha

Mocha is a JavaScript test framework that runs on Node.js and in the browser. It allows you to define test suites and test cases using a simple and intuitive syntax.

#### Key Concepts

*   **Test Suite:** A group of related tests, defined using the `describe` function.
*   **Test Case:** An individual test, defined using the `it` function.
*   **Hooks:** Functions that run before or after test cases, such as `before` (runs before all tests) and `after` (runs after all tests).

#### Example

```javascript
describe('Carts API', () => {
    // Setup: Crear usuarios y establecer sesiones con cookies
    before(async () => {
        // ...
    });

    describe('POST /api/carts', () => {
        it('deber√≠a crear un carrito con sesi√≥n de usuario regular', async () => {
            // ...
        });
    });

    // Cleanup despu√©s de los tests
    after(async () => {
        // ...
    });
});
```

### Chai

Chai is an assertion library that provides a variety of assertion styles, making it easy to write expressive and readable tests.

#### Key Concepts

*   **Expect:** A function used to make assertions about the expected behavior of the code.
*   **Assertion Styles:** Chai provides several assertion styles, such as `expect`, `should`, and `assert`.

#### Example

```javascript
it('deber√≠a crear un carrito con sesi√≥n de usuario regular', async () => {
    expect(res.status).to.equal(201);
    expect(res.body).to.have.property('status', 'success');
});
```

### Supertest

Supertest is a library for testing HTTP APIs. It allows you to make HTTP requests to the server and assert the expected responses.

#### Key Concepts

*   **Agent:** An object that maintains cookies and session information across requests.
*   **HTTP Methods:** Supertest provides methods for making different types of HTTP requests, such as `get`, `post`, `put`, and `delete`.
*   **Send:** A method for sending data with the request (e.g., in the request body for POST and PUT requests).

#### Example

```javascript
it('deber√≠a crear un carrito con sesi√≥n de usuario regular', async () => {
    const res = await userAgent
        .post('/api/carts');

    expect(res.status).to.equal(201);
    expect(res.body).to.have.property('status', 'success');
});
```

### Swagger

Swagger is a specification and framework for documenting APIs. It allows you to define the API endpoints, request parameters, and response formats in a standardized way.

#### Key Concepts

*   **API Documentation:** A document that describes the API endpoints, request parameters, and response formats.
*   **Swagger UI:** A user interface for exploring the API documentation.

#### Example

The Swagger documentation for this API is available at http://localhost:8080/api/docs/. It provides a comprehensive overview of all the available endpoints and their parameters.

For example, the documentation for the `POST /api/carts` endpoint shows that it creates a new cart.

```
POST /api/carts
```

This endpoint requires authentication.

### Complete Supertest Example

```javascript
describe('Carts API', () => {
    let adminAgent;
    let userAgent;
    let testCartId; // Para almacenar el ID del carrito creado
    let testProductId; // Para almacenar el ID de un producto de prueba

    // Datos de usuarios para testing
    const adminUser = {
        first_name: "Admin",
        last_name: "Test",
        email: `admin${Date.now()}@example.com`,
        age: 30,
        password: "123",
        role: "admin"
    };

    const regularUser = {
        first_name: "User",
        last_name: "Test",
        email: `user${Date.now()}@example.com`,
        age: 25,
        password: "123",
        role: "user"
    };

    // Setup: Crear usuarios y establecer sesiones con cookies
    before(async () => {
        // Crear agentes que mantienen cookies autom√°ticamente
        adminAgent = request.agent(server);
        userAgent = request.agent(server);

        try {
            // Registrar y loguear usuario admin
            await adminAgent
                .post('/api/sessions/register')
                .send(adminUser);

            const adminLoginRes = await adminAgent
                .post('/api/sessions/login')
                .send({ email: adminUser.email, password: adminUser.password });

            console.log('Admin login status:', adminLoginRes.status);
            expect(adminLoginRes.status).to.be.oneOf([200, 302]); // Verificar login exitoso

            // Registrar y loguear usuario regular
            await userAgent
                .post('/api/sessions/register')
                .send(regularUser);

            const userLoginRes = await userAgent
                .post('/api/sessions/login')
                .send({ email: regularUser.email, password: regularUser.password });

            console.log('User login status:', userLoginRes.status);
            expect(userLoginRes.status).to.be.oneOf([200, 302]); // Verificar login exitoso

        } catch (error) {
            console.error('Error en setup:', error.message);
            throw error; // Re-lanzar el error para que falle el test si el setup no funciona
        }
    });

    // Hook para crear un producto de prueba antes de los tests de carrito
    before(async () => {
        try {
            const uniqueCode = `cart_prod_${Date.now()}`;
            const testProduct = {
                title: "Cart Test Product",
                stock: 50,
                price: 500,
                description: "Producto para test de carrito",
                category: "Test",
                code: uniqueCode,
                thumbnail: "cart-test-image.jpg",
                status: true
            };

            const res = await adminAgent
                .post('/api/products')
                .send(testProduct);

            console.log('Create product response:', res.status, res.body);

            if (res.status === 201) {
                // Capturar el ID del producto de manera m√°s robusta
                testProductId = res.body.product?._id || 
                               res.body.product?.id || 
                               res.body.payload?._id || 
                               res.body.payload?.id ||
                               res.body._id ||
                               res.body.id;
                
                console.log('Test product created with ID:', testProductId);
                expect(testProductId).to.exist;
            } else {
                console.error('Failed to create test product:', res.status, res.body);
                throw new Error(`Failed to create test product: ${res.status}`);
            }
        } catch (error) {
            console.error('Error creating test product:', error.message);
            throw error;
        }
    });

    describe('POST /api/carts', () => {
        it('deber√≠a crear un carrito con sesi√≥n de usuario regular', async () => {
            const res = await userAgent
                .post('/api/carts');

            console.log('Create cart response:', res.status, res.body);

            expect(res.status).to.equal(201);
            expect(res.body).to.have.property('status', 'success');
            
            // Capturar el ID del carrito de manera m√°s robusta
            testCartId = res.body.payload?._id || 
                        res.body.payload?.id || 
                        res.body.cart?._id || 
                        res.body.cart?.id ||
                        res.body._id ||
                        res.body.id ||
                        res.body.cartId;
            
            console.log('Captured cartId:', testCartId);
            expect(testCartId).to.exist;
            
            console.log('Test cart created with ID:', testCartId);
        });

        it('deber√≠a fallar al crear un carrito sin autenticaci√≥n', async () => {
            const res = await request(server)
                .post('/api/carts');

            expect(res.status).to.be.oneOf([401, 403]); // Permitir ambos c√≥digos de error de autenticaci√≥n
        });
    });

    describe('GET /api/carts/:cid', () => {
        it('deber√≠a mostrar un carrito guardado con sesi√≥n de usuario regular', async () => {
            if (!testCartId) {
                throw new Error('No testCartId available - el test de creaci√≥n de carrito debe ejecutarse primero');
            }
            
            const res = await userAgent
                .get(`/api/carts/${testCartId}`);

            console.log('Get cart response:', res.status, res.body);

            expect(res.status).to.equal(200);
            expect(res.body).to.have.property('status', 'success');
            
            // Flexibilidad en la estructura de respuesta
            const cart = res.body.payload || res.body.cart;
            expect(cart).to.exist;
            
            const cartId = cart._id || cart.id;
            expect(cartId.toString()).to.equal(testCartId.toString());
            expect(cart.products).to.be.an('array');
        });

        it('deber√≠a fallar al mostrar un carrito sin autenticaci√≥n', async () => {
            if (!testCartId) {
                console.log('No testCartId available, skipping test');
                this.skip();
                return;
            }
            
            const res = await request(server)
                .get(`/api/carts/${testCartId}`);

            expect(res.status).to.be.oneOf([401, 403]);
        });

        it('deber√≠a devolver 404 para carrito inexistente', async () => {
            const fakeId = '64a1b2c3d4e5f6789abcdef0'; // ObjectId v√°lido pero inexistente
            const res = await userAgent
                .get(`/api/carts/${fakeId}`);

            console.log('Get nonexistent cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });
    });

    describe('POST /api/carts/:cid/products/:pid', () => {
        it('deber√≠a agregar un producto a un carrito con sesi√≥n de usuario regular', async () => {
            if (!testCartId || !testProductId) {
                throw new Error('No testCartId or testProductId available - tests anteriores deben ejecutarse primero');
            }
            
            const res = await userAgent
                .post(`/api/carts/${testCartId}/products/${testProductId}`)
                .send({ quantity: 2 });

            console.log('Add product to cart response:', res.status, res.body);

            expect(res.status).to.equal(200);
            expect(res.body).to.have.property('status', 'success');
            
            const cart = res.body.payload || res.body.cart;
            expect(cart).to.exist;
            
            const cartId = cart._id || cart.id;
            expect(cartId.toString()).to.equal(testCartId.toString());
            expect(cart.products).to.be.an('array').that.is.not.empty;
            
            // Buscar el producto agregado de manera m√°s flexible
            const addedProduct = cart.products.find(p => {
                const productId = p.product?._id || p.product?.id || p.product;
                return productId.toString() === testProductId.toString();
            });
            expect(addedProduct).to.exist;
            expect(addedProduct.quantity).to.equal(2);
        });

        it('deber√≠a fallar al agregar un producto sin autenticaci√≥n', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const res = await request(server)
                .post(`/api/carts/${testCartId}/products/${testProductId}`)
                .send({ quantity: 1 });

            expect(res.status).to.be.oneOf([401, 403]);
        });

        it('deber√≠a fallar al agregar un producto a un carrito inexistente', async () => {
            if (!testProductId) {
                console.log('No testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const fakeCartId = '64a1b2c3d4e5f6789abcdef0';
            const res = await userAgent
                .post(`/api/carts/${fakeCartId}/products/${testProductId}`)
                .send({ quantity: 1 });

            console.log('Add product to nonexistent cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });

        it('deber√≠a fallar al agregar un producto inexistente a un carrito', async () => {
            if (!testCartId) {
                console.log('No testCartId available, skipping test');
                this.skip();
                return;
            }
            
            const fakeProductId = '64a1b2c3d4e5f6789abcdef0';
            const res = await userAgent
                .post(`/api/carts/${testCartId}/products/${fakeProductId}`)
                .send({ quantity: 1 });

            console.log('Add nonexistent product to cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });
    });

    describe('PUT /api/carts/:cid', () => {
        it('deber√≠a modificar un carrito con sesi√≥n de usuario regular', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const updateData = {
                products: [
                    { product: testProductId, quantity: 5 }
                ]
            };
            
            const res = await userAgent
                .put(`/api/carts/${testCartId}`)
                .send(updateData);

            console.log('Update cart response:', res.status, res.body);

            expect(res.status).to.equal(200);
            expect(res.body).to.have.property('status', 'success');
            
            const cart = res.body.payload || res.body.cart;
            expect(cart).to.exist;
            
            const cartId = cart._id || cart.id;
            expect(cartId.toString()).to.equal(testCartId.toString());
            expect(cart.products).to.be.an('array').with.lengthOf(1);
            expect(cart.products[0].quantity).to.equal(5);
        });

        it('deber√≠a fallar al modificar un carrito sin autenticaci√≥n', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const updateData = { products: [{ product: testProductId, quantity: 1 }] };
            const res = await request(server)
                .put(`/api/carts/${testCartId}`)
                .send(updateData);

            expect(res.status).to.be.oneOf([401, 403]);
        });

        it('deber√≠a fallar al modificar un carrito inexistente', async () => {
            if (!testProductId) {
                console.log('No testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const fakeCartId = '64a1b2c3d4e5f6789abcdef0';
            const updateData = { products: [{ product: testProductId, quantity: 1 }] };
            const res = await userAgent
                .put(`/api/carts/${fakeCartId}`)
                .send(updateData);

            console.log('Update nonexistent cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });
    });

    describe('DELETE /api/carts/:cid/product/:pid', () => {
        it('deber√≠a eliminar un producto de un carrito con sesi√≥n de usuario regular', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            // Primero, aseg√∫rate de que el producto est√© en el carrito
            await userAgent
                .post(`/api/carts/${testCartId}/products/${testProductId}`)
                .send({ quantity: 1 });

            const res = await userAgent
                .delete(`/api/carts/${testCartId}/product/${testProductId}`);

            console.log('Delete product from cart response:', res.status, res.body);

            expect(res.status).to.equal(200);
            expect(res.body).to.have.property('status', 'success');
            
            const cart = res.body.payload || res.body.cart;
            expect(cart).to.exist;
            
            const cartId = cart._id || cart.id;
            expect(cartId.toString()).to.equal(testCartId.toString());
            
            // Verificar que el producto ya no est√© en el carrito
            const deletedProduct = cart.products.find(p => {
                const productId = p.product?._id || p.product?.id || p.product;
                return productId.toString() === testProductId.toString();
            });
            expect(deletedProduct).to.be.undefined;
        });

        it('deber√≠a fallar al eliminar un producto sin autenticaci√≥n', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const res = await request(server)
                .delete(`/api/carts/${testCartId}/product/${testProductId}`);

            expect(res.status).to.be.oneOf([401, 403]);
        });

        it('deber√≠a fallar al eliminar un producto de un carrito inexistente', async () => {
            if (!testProductId) {
                console.log('No testProductId available, skipping test');
                this.skip();
                return;
            }
            
            const fakeCartId = '64a1b2c3d4e5f6789abcdef0';
            const res = await userAgent
                .delete(`/api/carts/${fakeCartId}/product/${testProductId}`);

            console.log('Delete product from nonexistent cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });

        it('deber√≠a fallar al eliminar un producto inexistente de un carrito', async () => {
            if (!testCartId) {
                console.log('No testCartId available, skipping test');
                this.skip();
                return;
            }
            
            const fakeProductId = '64a1b2c3d4e5f6789abcdef0';
            const res = await userAgent
                .delete(`/api/carts/${testCartId}/product/${fakeProductId}`);

            console.log('Delete nonexistent product from cart response:', res.status, res.body);
            expect(res.status).to.equal(404);
        });
    });

    describe('POST /api/carts/:cid/purchase', () => {
        it('deber√≠a completar la compra de un carrito con sesi√≥n de usuario regular', async () => {
            if (!testCartId || !testProductId) {
                console.log('No testCartId or testProductId available, skipping test');
                this.skip();
                return;
            }
            
            // Aseg√∫rate de que el carrito tenga al menos un producto para comprar
            await userAgent
                .post(`/api/carts/${testCartId}/products/${testProductId}`)
                .send({ quantity: 1 });

            const res = await userAgent
                .post(`/api/carts/${testCartId}/purchase`);

            console.log('Purchase cart response:', res.status, res.body);

            expect(res.status).to.equal(200);
            expect(res.body).to.have.property('status', 'success');
            
            const payload = res.body.payload;
            expect(payload).to.have.property('ticket');
            expect(payload.ticket).to.have.property('_id');
            expect(payload.ticket.purchaser).to.equal(regularUser.email);
        });

        it('deber√≠a fallar al completar la compra sin autenticaci√≥n', async () => {
            if (!testCartId) {
                console.log('No testCartId available, skipping test');
                this.skip();
                return;
            }
            
            const res = await request(server)
                .post(`/api/carts/${testCartId}/purchase`);

            expect(res.status).to.be.oneOf([401, 403]);
        });

        it('deber√≠a fallar al completar la compra de un carrito inexistente', async () => {
            const fakeCart
